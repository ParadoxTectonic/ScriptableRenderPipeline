#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ScreenSpaceLighting/SSLVDCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingSampling.hlsl"

#undef _AOStepCount
#define _AOStepCount 3

//#pragma enable_d3d11_debug_symbols

#pragma kernel SSLVDMain_FullRes SSLVD_KERNEL_NAME=SSLVDMain_FullRes
#pragma kernel SSLVDMain_HalfRes SSLVD_KERNEL_NAME=SSLVDMain_HalfRes HALF_RES

// --------------------------------------------
// Integration functions
// --------------------------------------------

float AcosAppx(float x)
{
    return mad(mad(sqrt(1. - Sq(Sq(x))), 0.54, -PI/2), x, PI/2);
}

void IntegrateHarmonics(float cosH1, float cosH2, float cosPhi, float sinPhi, out float s0, out float4 s1, out float4 s5)
{
    float cosH1Sq = cosH1 * cosH1;
    float cosH2Sq = cosH2 * cosH2;
    float sinH1Sq = 1 - cosH1Sq;
    float sinH2Sq = 1 - cosH2Sq;
    float sinH1 = sqrt(sinH1Sq);
    float sinH2 = sqrt(sinH2Sq);

    float tmp1  = rsqrt(16*PI/3) * (mad(cosH1, sinH1, -AcosAppx(cosH1)) - mad(cosH2, sinH2, -AcosAppx(cosH2)));
    float tmp2a = rsqrt(48*PI/5) * (4 + mad(cosH1, -3, cosH1Sq) + mad(cosH2, -3, cosH2Sq));
    float tmp2b = rsqrt(12*PI/5) * (sinH2*sinH2Sq - sinH1*sinH1Sq);
    s0    = rsqrt(4*PI) * (2 - cosH1 - cosH2);
    s1[0] = sinPhi*tmp1;
    s1[1] = rsqrt(16*PI/3) * (sinH1Sq + sinH2Sq);
    s1[2] = cosPhi*tmp1;
    s1[3] = cosPhi*sinPhi*tmp2a;
    s5[0] = sinPhi * tmp2b;
    s5[1] = rsqrt(16*PI/5) * (cosH1*sinH1Sq + cosH2*sinH2Sq);
    s5[2] = cosPhi * tmp2b;
    s5[3] = mad(cosPhi, cosPhi, -0.5) * tmp2a;
}

void RotateSphericalHarmonicsL2(float3x3 m, float s0, float4 s1, float4 s5, out float r0, out float4 r1, out float4 r5)
{
    // L0
    r0 = s0;

    // L1
    r1.zxy = mul(m, s1.zxy);

    // L2
    float2 s4 = float2(s5[0], s1[3]);
    s4 += s5[3] - s5[2];
    s4[0] += s5[3];
    s4[1] += sqrt(float(3))*s5[1];
    float3 s6 = float3(s1[3], s5.zx);

    float3x3 b = float3x3(m[0].xxy + m[0].yzz, m[1].xxy + m[1].yzz, m[2].xxy + m[2].yzz);

    r1[3] = dot(s4.xy, m[0].xz*m[1].xz) + dot(s6, b[0]*b[1]);
    r5[0] = dot(s4.xy, m[1].xz*m[2].xz) + dot(s6, b[1]*b[2]);
    r5[1] = float(sqrt(3.)/2)*(dot(s4.xy, mad(m[2].xz, m[2].xz, float(-1./3))) + dot(s6, mad(b[2], b[2], float(-2./3))));
    r5[2] = dot(s4.xy, m[0].xz*m[2].xz) + dot(s6, b[0]*b[2]);
    r5[3] = float(0.5)*(dot(s4.xy, m[0].xz*m[0].xz - m[1].xz*m[1].xz) + dot(s6, b[0]*b[0] - b[1]*b[1]));
}

float NormalizedZCosineProduct(float s0, float4 s1, float4 s5)
{
    return s0*rsqrt(4*PI) + s1[1]*rsqrt(3*PI) + s5[1]*rsqrt(64*PI/5);
    //return s0*0.282095 + s1[1]*0.305377 + s5[1]*0.134041;
}

float3x3 GetNormalFrame(float3 n)
{
    float3 v = n.yzx;
    v.x = -v.x;
    v = normalize(cross(v, n));
    return float3x3(cross(n, v), v, n);
}

float UpdateHorizon(float maxH, float candidateH, float distSq, float invMaxDistSq, out float confidence)
{
    float falloff = rsqrt(rsqrt(saturate(distSq*invMaxDistSq)));    // slightly faster than pow(, 0.25)
    //float falloff = saturate(distSq*invMaxDistSq);

    falloff *= saturate(candidateH);   // don't care if occluded by stuff behind us

    confidence = 1 - falloff;

    return (candidateH > maxH) ? lerp(candidateH, maxH, falloff) : maxH;// lerp(maxH, candidateH, 0.03);   // TODO - rate should depend on number of steps
}

float2 GenWeyl(float i)
{
    return frac(i*float2(0.754877627, 0.569840252));
}

float Bayer2(uint2 i)
{
    i &= 1;
    return float(i.x + 2 * (i.x ^ i.y))*0.25;
}

float Bayer4(uint2 i)
{
    return Bayer2(i) + Bayer2(i/2)*0.25;
}

// --------------------------------------------
// Input generation functions
// --------------------------------------------

float3 GetPositionVS(float2 positionSS, float depth, out float rcpEyeDepth)
{
    rcpEyeDepth = RcpEyeDepth(depth, _ZBufferParams);
    float linearDepth = rcp(rcpEyeDepth);
    return float3(mad(positionSS, _AODepthToViewParams.xy, -_AODepthToViewParams.zw) * linearDepth, -linearDepth);
}

float2 ClampSamplePos(float2 p)
{
#ifdef HALF_RES
    return clamp(p, 2, _AOBufferSize.xy*2 - 2);
#else
    return clamp(p, 2, _AOBufferSize.xy - 2);
#endif
}

// --------------------------------------------
// Kernel
// --------------------------------------------

float HorizonLoop(float3 positionVS, float3 V, float2 rayStart, float2 rayDir, float rayOffset, float rayEnd, float invMaxDistSq, out float confidence)
{
    float maxHorizon = -1.0f;  // cos(pi)

    float t0 = sqrt(2.);
    float rayStep = pow(rayEnd/t0, rcp(float(_AOStepCount)));
    float t = t0*pow(rayStep, rayOffset);

    confidence = 0;

    const uint startWithLowerRes = 1;
    const uint startWithLowestRes = 2;
    [unroll]
    for (uint i = 0; i < _AOStepCount; i++)
    {
        float2 samplePos = ClampSamplePos(rayStart + t * rayDir);

        // Find horizons at these steps:
        float sampleDepth = GetDepthSample(samplePos, (i >= startWithLowerRes) + (i >= startWithLowestRes));
        float rcpEyeDepth;
        float3 samplePosVS = GetPositionVS(samplePos.xy, sampleDepth, rcpEyeDepth);

        float invMaxDistSqForOccluder = invMaxDistSq;

        // use attenuation radius of occluder instead of occludee - costs ~100us but mitigates the back shadow effect
        invMaxDistSqForOccluder *= positionVS.z*positionVS.z * rcpEyeDepth*rcpEyeDepth;

        float3 deltaPos = samplePosVS - positionVS;
        float deltaLenSq = dot(deltaPos, deltaPos);

        float currHorizon = clamp(dot(deltaPos, V) * rsqrt(deltaLenSq), -1, 1);
        float currConfidence;
        maxHorizon = UpdateHorizon(maxHorizon, currHorizon, deltaLenSq, invMaxDistSqForOccluder, currConfidence);
        confidence += (1 - confidence)*currConfidence;

        t *= rayStep;
    }

    return maxHorizon;
}

RW_TEXTURE2D_X(float, _AOPackedData);
RW_TEXTURE2D_X(float4, _AORawHarmonics1);
RW_TEXTURE2D_X(float4, _AORawHarmonics5);
TEXTURE2D_ARRAY(_BlueNoiseTexture);

[numthreads(8,8,1)]
void SSLVD_KERNEL_NAME(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);

    uint frame = uint(_AOTemporalRotationIdx);

    uint2 sourcePositionSS = dispatchThreadId.xy;
    uint2 noiseCoord = dispatchThreadId.xy;
#ifdef HALF_RES
    uint jiggleIndex = frame & 3;
    uint2 jiggle = uint2(jiggleIndex == 1 || jiggleIndex == 2, jiggleIndex == 1 || jiggleIndex == 3);

    // N.B. no idea why this coordinate works so much better for sampling the noise compared to sourcePositionSS (which includes jiggle swizzling) - we're in hack territory
    // in theory we should be able to perfectly marry our jiggle here with the denoise jiggle; we're close, but not quite there
    noiseCoord = sourcePositionSS * 2 + jiggle;

    jiggle = jiggle ^ (dispatchThreadId.yx & 1);

    sourcePositionSS = sourcePositionSS * 2 + jiggle;
#endif

    // Read buffers as early as possible.
    float currDepth = GetDepthForCentral(sourcePositionSS);
    float rcpEyeDepth;
    float3 positionVS = GetPositionVS(sourcePositionSS, currDepth, rcpEyeDepth);


    float2 rayStart = sourcePositionSS;
    float integral = 0;
    float4 harmonics1 = 0;
    float4 harmonics5 = 0;

    const int dirCount = 6;// _AODirectionCount;

    float phi0 = frac(Bayer4(dispatchThreadId.xy) + (frame&1) * 0.5)/dirCount;

    float3 V = normalize(-positionVS);

    float pixelsPerVS = _AOFOVCorrection * rcpEyeDepth;
    float invMaxDistSq = pixelsPerVS*pixelsPerVS * rcp(_AOMaxRadiusInPixels*_AOMaxRadiusInPixels);
    invMaxDistSq = min(invMaxDistSq, _AOInvRadiusSq);

    [loop]
    for (int i = 0; i < dirCount; ++i)
    {
        float offset = InterleavedGradientNoise((frame & 1) ? (noiseCoord.yx ^ uint2(0xfff, 0)) : noiseCoord, i);

        float2 dir;
        sincos(frac(phi0 + float(i)/dirCount)*PI, dir.y, dir.x);

        // Find horizons
        float2 maxHorizons, confidence;
        maxHorizons.x = HorizonLoop(positionVS, V, rayStart, -dir, offset, _AOMaxRadiusInPixels, invMaxDistSq, confidence.x);
        maxHorizons.y = HorizonLoop(positionVS, V, rayStart, +dir, offset, _AOMaxRadiusInPixels, invMaxDistSq, confidence.y);

        maxHorizons = lerp(-maxHorizons.yx, maxHorizons, confidence);

        // Integrate horizons
        float s0;
        float4 s1, s5;
        IntegrateHarmonics(maxHorizons.x, maxHorizons.y, dir.x, dir.y, s0, s1, s5);

        integral += s0;
        harmonics1 += s1;
        harmonics5 += s5;
    }

    float3x3 worldToLocal;  // coordinate frame with z basis aligned to view vector
    worldToLocal[2] = float3(mul(V, (float3x3)UNITY_MATRIX_V));
    worldToLocal[1] = normalize(cross(UNITY_MATRIX_V[0].xyz, worldToLocal[2]));
    worldToLocal[0] = cross(worldToLocal[2], worldToLocal[1]);
    RotateSphericalHarmonicsL2(transpose(worldToLocal), integral, harmonics1, harmonics5, integral, harmonics1, harmonics5);

    integral *= PI / dirCount;
    harmonics1 *= PI / dirCount;
    harmonics5 *= PI / dirCount;

    //harmonics1[3] = 0;
    //harmonics5 = 0;

    NormalizeRange(integral, harmonics1, harmonics5);

    if (currDepth == UNITY_RAW_FAR_CLIP_VALUE)
    {
        integral = 1;
    }

    //_AOPackedData[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = 1 - integral;
    _AOPackedData[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = PackAODepth(1 - integral, rcpEyeDepth);
    _AORawHarmonics1[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = harmonics1;
    _AORawHarmonics5[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = harmonics5;
}
