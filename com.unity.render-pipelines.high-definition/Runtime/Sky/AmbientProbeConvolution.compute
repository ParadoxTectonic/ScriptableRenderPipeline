#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Hammersley.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Sampling.hlsl"

#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#pragma kernel AmbientProbeConvolution KERNEL_NAME=AmbientProbeConvolution
#pragma kernel CompactProbeConvolution KERNEL_NAME=CompactProbeConvolution COMPACT_OUTPUT

#ifdef COMPACT_OUTPUT

RW_TEXTURE2D(float4, _AmbientProbeOutputBuffer);

#else

RWStructuredBuffer<float> _AmbientProbeOutputBuffer;

#endif

uint _AmbientProbeOutputOffset;
TEXTURECUBE(_AmbientProbeInputCubemap);

// Constants from SetSHEMapConstants function in the Stupid Spherical Harmonics Tricks paper:
// http://www.ppsloan.org/publications/StupidSH36.pdf

// Jay 03/03/2020 - Refactored these constants. The last one was wrong, but the error was slight (about 9%).
// The paper cited above doesn't illuminate much, tbh - these were derived from first principles.
// Would prefer to remove the cosine convolution here, and apply it when shading. Note that the volumetric lighting system 
// deconvolves this result to recover the pure sky projection, and visibility field AO would have to do the same.

        //  [SH basis coeff] * [clamped cosine convolution factor]
#define fC0 (rsqrt(PI*4)    )// * rsqrt(PI*4)     )
#define fC1 (rsqrt(PI*4/3)  )// * rsqrt(PI*3)     )
#define fC2 (rsqrt(PI*4/15) )// * rsqrt(PI*64/15) )
#define fC3 (rsqrt(PI*16/5) )// * rsqrt(PI*256/5) )
#define fC4 (rsqrt(PI*16/15))// * rsqrt(PI*256/15))

#define SAMPLE_COUNT 256
#define SH_COEFF_COUNT 27

#if defined(PLATFORM_SUPPORTS_WAVE_INTRINSICS) && defined(PLATFORM_LANE_COUNT)
    // Allocate space to accumulate all waves result. We need space for each single wavefront (because we can't atomic add floats)
    groupshared float outputSHCoeffsLDS[SH_COEFF_COUNT * SAMPLE_COUNT / PLATFORM_LANE_COUNT];
#else
    // Allocate space for parallel reduction (so half the number of samples.
    groupshared float outputSHCoeffsLDS[SH_COEFF_COUNT * SAMPLE_COUNT / 2];
#endif

static const float ConvolveCosineLobeBandFactor[] = { fC0, fC1, fC1, fC1, fC2, fC2, fC3, fC2, fC4 };

[numthreads(SAMPLE_COUNT, 1, 1)]
void KERNEL_NAME(uint dispatchThreadId : SV_DispatchThreadID)
{
    uint sampleCount = SAMPLE_COUNT;

    float2 cubeSize;
    _AmbientProbeInputCubemap.GetDimensions(cubeSize.x, cubeSize.y);

    // Prefiltered importance sampling
    // Use lower MIP-map levels for fetching samples with low probabilities
    // in order to reduce the variance.
    // Ref: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch20.html
    //
    // - OmegaS: Solid angle associated with the sample
    // - OmegaP: Solid angle associated with the texel of the cubemap
    float invOmegaP = (6.0 * cubeSize.x * cubeSize.y) / FOUR_PI;
    float pdf = 1.0 / FOUR_PI; // Solid angle of the sphere is 4*PI
    float omegaS = rcp(sampleCount) * rcp(pdf);
    float mipLevel = 0.5 * log2(omegaS * invOmegaP);

    float2 u = Hammersley2d(dispatchThreadId, sampleCount);
    float3 n = SampleSphereUniform(u.x, u.y);

    // Sample once per thread
    float4 value = SAMPLE_TEXTURECUBE_LOD(_AmbientProbeInputCubemap, s_linear_clamp_sampler, n, mipLevel);

    float outputSHCoeffs[SH_COEFF_COUNT];

    for (int channel = 0; channel < 3; ++channel)
    {
        outputSHCoeffs[channel * 9 + 0] = value[channel];
        outputSHCoeffs[channel * 9 + 1] = n.y * value[channel];
        outputSHCoeffs[channel * 9 + 2] = n.z * value[channel];
        outputSHCoeffs[channel * 9 + 3] = n.x * value[channel];
        outputSHCoeffs[channel * 9 + 4] = n.x * n.y * value[channel];
        outputSHCoeffs[channel * 9 + 5] = n.y * n.z * value[channel];
        outputSHCoeffs[channel * 9 + 6] = (3.0 * n.z * n.z - 1.0) * value[channel];
        outputSHCoeffs[channel * 9 + 7] = n.x * n.z * value[channel];
        outputSHCoeffs[channel * 9 + 8] = (n.x * n.x - n.y * n.y) * value[channel];
    }

    uint i;
#ifdef PLATFORM_SUPPORTS_WAVE_INTRINSICS

    // Sum up all threads result and broadcast
    for (i = 0; i < SH_COEFF_COUNT; ++i)
    {
        outputSHCoeffs[i] = WaveActiveSum(outputSHCoeffs[i]);
    }

    // First thread of each wave stores the result in LDS
    uint laneCount = WaveGetLaneCount();
    if (dispatchThreadId % laneCount == 0)
    {
        for (i = 0; i < SH_COEFF_COUNT; ++i)
        {
            uint offset = (dispatchThreadId / laneCount) * SH_COEFF_COUNT;
            outputSHCoeffsLDS[i + offset] = outputSHCoeffs[i];
        }
    }

    GroupMemoryBarrierWithGroupSync();

    // Read back the result to VGPRs to store it to memory at the end
    // First wave intializes the array
    for (i = 0; i < SH_COEFF_COUNT; ++i)
    {
        outputSHCoeffs[i] = outputSHCoeffsLDS[i];
    }

    // Then accumulate remaining waves
    uint waveCount = sampleCount / laneCount;
    for (uint wave = 1; wave < waveCount; ++wave)
    {
        for (i = 0; i < SH_COEFF_COUNT; ++i)
        {
            outputSHCoeffs[i] += outputSHCoeffsLDS[i + wave * SH_COEFF_COUNT];
        }
    }
#else
    // Parallel reduction of all threads result.
    for (uint k = 0; k < FastLog2(SAMPLE_COUNT); ++k)
    {
        // Each loop iteration, even threads store their result in LDS, odd threads sum them up back to local VGPR until all results are summed up.
        if ((dispatchThreadId & ((2 << k) - 1)) == (1 << k))
        {
            uint index = dispatchThreadId >> (k + 1);
            for (uint coeff = 0; coeff < SH_COEFF_COUNT; ++coeff)
            {
                outputSHCoeffsLDS[index * SH_COEFF_COUNT + coeff] = outputSHCoeffs[coeff];
            }
        }

        GroupMemoryBarrierWithGroupSync();

        if ((dispatchThreadId & ((2 << k) - 1)) == 0)
        {
            uint index = dispatchThreadId >> (k + 1);
            for (uint coeff = 0; coeff < SH_COEFF_COUNT; ++coeff)
            {
                outputSHCoeffs[coeff] += outputSHCoeffsLDS[index * SH_COEFF_COUNT + coeff];
            }
        }

        GroupMemoryBarrierWithGroupSync();
    }
#endif

    float weight = 4.0 * PI / (sampleCount);

    // Write to memory and convolution + weighing
    if (dispatchThreadId == 0)
    {
#ifdef COMPACT_OUTPUT

        const uint cRgbCoeffs = SH_COEFF_COUNT / 3;

        for (i = 0; i < cRgbCoeffs; ++i)
        {
            float3 rgb = float3(
                outputSHCoeffs[0 * cRgbCoeffs + i] * ConvolveCosineLobeBandFactor[i] * weight,
                outputSHCoeffs[1 * cRgbCoeffs + i] * ConvolveCosineLobeBandFactor[i] * weight,
                outputSHCoeffs[2 * cRgbCoeffs + i] * ConvolveCosineLobeBandFactor[i] * weight);

            // texture is arranged in 4x3 pixel blocks like this:
            // | sh0 sh1 sh2 sh3 |
            // | sh4 sh5 sh6 sh7 |
            // | sh8  X   X   X  |

            _AmbientProbeOutputBuffer[uint2(i & 3, _AmbientProbeOutputOffset*3 + i/3)] = float4(rgb, 0.0f);
        }

#else

        for (i = 0; i < SH_COEFF_COUNT; ++i)
        {
            _AmbientProbeOutputBuffer[_AmbientProbeOutputOffset * 27 + i] = outputSHCoeffs[i] * ConvolveCosineLobeBandFactor[i % 9] * weight;
        }

#endif
    }
}
